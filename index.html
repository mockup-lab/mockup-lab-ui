<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MockupLab.in - Interactive Template Deck</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom base styles */
        body {
            background-color: #0c111d; /* Darker base background */
            /* Gradient removed as canvas will cover it */
            overflow-x: hidden;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            color: #f3f4f6;
            padding-top: 5rem;
            position: relative; /* Needed for canvas positioning */
        }

        /* --- Canvas Background --- */
        #starfieldCanvas {
            position: fixed; /* Fixed position to stay behind content */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Place behind all other content */
            display: block; /* Remove extra space below canvas */
        }


        /* Branding */
        .brand-logo {
            position: absolute; /* Changed to absolute relative to body */
            top: 1.5rem;
            left: 1.5rem;
            font-size: 1.125rem;
            font-weight: 600;
            color: #9ca3af;
            z-index: 50; /* Ensure it's above canvas and other elements */
        }

        /* --- Animated Search Input --- */
        .search-container {
            width: 100%;
            max-width: 320px; /* max-w-xs */
            margin: 1.5rem auto 2.5rem auto;
            position: relative; /* Keep relative for icon */
            z-index: 40; /* Above canvas */
            transition: max-width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .search-container.search-focused { max-width: 600px; /* max-w-xl */ }
        @media (min-width: 640px) { /* sm */
             .search-container { max-width: 448px; /* max-w-md */ }
             .search-container.search-focused { max-width: 672px; /* max-w-2xl */ }
        }
         @media (min-width: 1024px) { /* lg */
             .search-container { max-width: 576px; /* max-w-lg */ }
             .search-container.search-focused { max-width: 768px; /* max-w-3xl */ }
         }

        .search-input { /* Styles remain the same */
            width: 100%; padding: 0.875rem 1rem 0.875rem 2.75rem; border-radius: 9999px;
            border: 1px solid #374151; background-color: #1f2937; color: #f3f4f6;
            font-size: 1rem; transition: border-color 0.3s ease, box-shadow 0.3s ease; appearance: none;
        }
        .search-input::placeholder { color: #6b7280; }
        .search-input:focus { outline: none; border-color: #4f46e5; box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.5); }
        .search-input::-webkit-search-cancel-button { -webkit-appearance: none; appearance: none; }
        .search-icon { position: absolute; left: 1rem; top: 50%; transform: translateY(-50%); color: #6b7280; pointer-events: none; }

        /* Filter Styles */
        .filter-container { /* Styles remain the same */
            display: flex; flex-wrap: wrap; justify-content: center; gap: 0.75rem; padding: 0 1rem;
            width: 100%; z-index: 30; margin-bottom: 2.5rem;
        }
        .filter-button { /* Styles remain the same */
            padding: 0.5rem 1rem; border: 1px solid #4b5563; background-color: transparent; color: #d1d5db;
            border-radius: 9999px; font-size: 0.875rem; font-weight: 500; cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        .filter-button:hover { background-color: #374151; border-color: #525f73; }
        .filter-button.active { background-color: #4f46e5; color: #ffffff; border-color: #4f46e5; }

        /* --- Deck Container & Responsiveness --- */
        .deck-container { /* Styles remain the same */
            perspective: 1500px; width: 100%; display: flex; justify-content: center; align-items: center;
            position: relative; padding: 0 1rem; flex-grow: 1; min-height: 500px; margin-bottom: 2rem; z-index: 10; /* Ensure deck is above canvas */
        }
         @media (min-width: 640px) { /* sm */ .deck-container { padding: 0 2rem; min-height: 550px; } }
         @media (min-width: 1024px) { /* lg */ .deck-container { padding: 0 5%; min-height: 600px; perspective: 1800px; } }

        .deck { /* Styles remain the same */
            transform-style: preserve-3d; position: relative; width: 300px; height: 440px;
            transition: transform 0.6s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
         @media (min-width: 640px) { /* sm */ .deck { width: 350px; height: 500px; } }
         @media (min-width: 1024px) { /* lg */ .deck { width: 400px; height: 550px; } }

        .card { /* Base card styles remain the same */
            position: absolute; width: 100%; height: 100%; border-radius: 1rem; overflow: hidden;
            background-color: rgba(55, 65, 81, 0.8); /* bg-gray-700 with slight transparency */
            backdrop-filter: blur(4px); /* Add blur effect behind cards */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3), 0 6px 6px rgba(0, 0, 0, 0.2);
            cursor: pointer; transition: transform 0.6s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.6s cubic-bezier(0.25, 0.8, 0.25, 1);
            backface-visibility: hidden; display: flex; flex-direction: column; transform-origin: center center;
        }
        /* Card positioning styles remain the same */
        .card.active { transform: translateX(0) translateZ(0) rotateY(0); opacity: 1; z-index: 10; }
        .card.prev { transform: translateX(-60%) translateZ(-200px) rotateY(35deg); opacity: 0.7; z-index: 5; }
        .card.next { transform: translateX(60%) translateZ(-200px) rotateY(-35deg); opacity: 0.7; z-index: 5; }
        .card.prev-hidden { transform: translateX(-100%) translateZ(-400px) rotateY(45deg); opacity: 0; z-index: 1; pointer-events: none; }
        .card.next-hidden { transform: translateX(100%) translateZ(-400px) rotateY(-45deg); opacity: 0; z-index: 1; pointer-events: none; }
        .card.hidden { transform: translateX(0) translateZ(-600px) rotateY(0); opacity: 0; z-index: 0; pointer-events: none; }
        /* Responsive Card Positioning Adjustments remain the same */
        @media (max-width: 1023px) { .card.prev { transform: translateX(-55%) translateZ(-150px) rotateY(30deg); } .card.next { transform: translateX(55%) translateZ(-150px) rotateY(-30deg); } .card.prev-hidden { transform: translateX(-90%) translateZ(-300px) rotateY(40deg); } .card.next-hidden { transform: translateX(90%) translateZ(-300px) rotateY(-40deg); } }
        @media (max-width: 639px) { .card.prev { transform: translateX(-50%) translateZ(-100px) rotateY(25deg); } .card.next { transform: translateX(50%) translateZ(-100px) rotateY(-25deg); } .card.prev-hidden { transform: translateX(-80%) translateZ(-200px) rotateY(35deg); } .card.next-hidden { transform: translateX(80%) translateZ(-200px) rotateY(-35deg); } }

        /* Filter animation classes remain the same */
        .card.fade-out { opacity: 0 !important; transform: scale(0.9); transition: opacity 0.3s ease-out, transform 0.3s ease-out; }
        .card.fade-in { opacity: 0; transform: scale(0.95); animation: fadeIn 0.4s ease-out forwards; animation-delay: 0.1s; }
        @keyframes fadeIn { to { opacity: 1; transform: scale(1); } }

        /* Card content styles remain the same */
        .card img { width: 100%; height: 65%; object-fit: cover; display: block; background-color: #4b5563; }
        .card-content { padding: 1rem; flex-grow: 1; display: flex; flex-direction: column; justify-content: space-between; }
        .card-title { font-size: 1.125rem; font-weight: 600; margin-bottom: 0.25rem; color: #ffffff; }
        .card-description { font-size: 0.875rem; color: #d1d5db; margin-bottom: 0.5rem; line-height: 1.4; }
        .card-tags { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: auto; }
        .card-tag { background-color: #4b5563; color: #e5e7eb; padding: 0.25rem 0.5rem; border-radius: 9999px; font-size: 0.75rem; font-weight: 500; }
        @media (min-width: 1024px) { .card-title { font-size: 1.25rem; } }

        /* Navigation Buttons remain the same */
        .nav-arrow { position: absolute; top: 50%; transform: translateY(-50%); background-color: rgba(255, 255, 255, 0.1); border: none; border-radius: 50%; padding: 0.5rem; cursor: pointer; z-index: 20; transition: background-color 0.3s ease, transform 0.3s ease; color: #e5e7eb; }
        @media (min-width: 640px) { .nav-arrow { padding: 0.75rem; } }
        .nav-arrow:hover { background-color: rgba(255, 255, 255, 0.2); transform: translateY(-50%) scale(1.1); }
        .nav-arrow:active { transform: translateY(-50%) scale(1.0); }
        .nav-arrow.left { left: -0.5rem; } .nav-arrow.right { right: -0.5rem; }
        @media (min-width: 640px) { .nav-arrow.left { left: 0; } .nav-arrow.right { right: 0; } }
        @media (min-width: 1024px) { .nav-arrow.left { left: 1%; } .nav-arrow.right { right: 1%; } }

        /* Modal Styles */
        .modal-overlay { /* Styles remain the same */
             position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 60; /* Ensure modal is above everything */ opacity: 0; transition: opacity 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); pointer-events: none;
        }
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .modal-content { /* Styles remain the same */
            background-color: rgba(31, 41, 55, 0.85); /* bg-gray-800 with transparency */
            backdrop-filter: blur(8px); /* More blur for modal */
            padding: 1.5rem; border-radius: 1rem; max-width: 90%; width: 700px; max-height: 90vh; overflow-y: auto; position: relative; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); transform: scale(0.95); transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
         @media (min-width: 640px) { .modal-content { padding: 2rem; } }
        .modal-overlay.visible .modal-content { transform: scale(1); }
        /* Modal inner elements styles remain the same */
        .modal-close-btn { position: absolute; top: 1rem; right: 1rem; background: none; border: none; color: #9ca3af; cursor: pointer; padding: 0.25rem; } .modal-close-btn:hover { color: #e5e7eb; }
        .modal-image { width: 100%; max-height: 400px; object-fit: cover; border-radius: 0.5rem; margin-bottom: 1.5rem; background-color: #4b5563; }
        .modal-title { font-size: 1.5rem; font-weight: 700; color: #ffffff; margin-bottom: 0.75rem; } @media (min-width: 640px) { .modal-title { font-size: 1.875rem; } }
        .modal-description { font-size: 1rem; color: #d1d5db; margin-bottom: 1.5rem; line-height: 1.6; }
        .modal-tags { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 2rem; }
        .modal-tag { background-color: #4b5563; color: #e5e7eb; padding: 0.25rem 0.75rem; border-radius: 9999px; font-size: 0.875rem; font-weight: 500; }
        .modal-actions { display: flex; flex-wrap: wrap; gap: 1rem; }
        .modal-button { padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 600; transition: background-color 0.2s ease, transform 0.2s ease; cursor: pointer; border: none; flex-grow: 1; text-align: center;} @media (min-width: 640px) { .modal-button { flex-grow: 0; } }
        .modal-button.primary { background-color: #4f46e5; color: #ffffff; } .modal-button.primary:hover { background-color: #4338ca; transform: translateY(-2px); }
        .modal-button.secondary { background-color: #4b5563; color: #e5e7eb; } .modal-button.secondary:hover { background-color: #525f73; transform: translateY(-2px); }

        /* No Results Message */
        .no-results-message { color: #9ca3af; text-align: center; position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 1.125rem; z-index: 1; /* Ensure it's above deck bg but below cards */ padding: 1rem; }

    </style>
</head>
<body>
    <canvas id="starfieldCanvas"></canvas>

    <div class="brand-logo">mockuplab.in</div>

    <div class="search-container" id="searchContainer">
        <input type="search" id="searchInput" class="search-input" placeholder="Describe the template you need...">
        <div class="search-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>
        </div>
    </div>

    <div id="filterContainer" class="filter-container">
        </div>

    <div class="deck-container" id="deckContainer">
        <button id="prevBtn" class="nav-arrow left">
             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
        </button>
        <div class="deck" id="deck">
            <p id="noResultsMessage" class="no-results-message" style="display: none;">No templates match your criteria.</p>
            </div>
        <button id="nextBtn" class="nav-arrow right">
             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
        </button>
    </div>

    <div id="modalOverlay" class="modal-overlay">
        <div id="modalContent" class="modal-content">
             <button id="modalCloseBtn" class="modal-close-btn"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg> </button>
             <img id="modalImage" src="" alt="Template Preview" class="modal-image" onerror="this.onerror=null; this.src='https://placehold.co/600x400/cccccc/ffffff?text=Image+Error';">
             <h2 id="modalTitle" class="modal-title"></h2> <p id="modalDescription" class="modal-description"></p>
             <div id="modalTags" class="modal-tags"></div> <div class="modal-actions"> <button class="modal-button primary">Live Preview</button> <button class="modal-button secondary">Download</button> </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('starfieldCanvas');
        const ctx = canvas.getContext('2d');
        const deckContainer = document.getElementById('deckContainer');
        const deck = document.getElementById('deck');
        const filterContainer = document.getElementById('filterContainer');
        const searchContainer = document.getElementById('searchContainer');
        const searchInput = document.getElementById('searchInput');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const modalOverlay = document.getElementById('modalOverlay');
        const modalContent = document.getElementById('modalContent');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const modalImage = document.getElementById('modalImage');
        const modalTitle = document.getElementById('modalTitle');
        const modalDescription = document.getElementById('modalDescription');
        const modalTags = document.getElementById('modalTags');
        const noResultsMessage = document.getElementById('noResultsMessage');

        // --- Data (Same as v5) ---
        const allTemplateData = [
             { index: 0, category: "Portfolio", title: "Modern Portfolio", description: "Sleek design for creatives.", longDescription: "This template features a clean layout with smooth animations...", image: "https://placehold.co/400x350/7c3aed/ffffff?text=Portfolio", tags: ["Portfolio", "Creative", "Minimal", "Responsive", "Design"] },
             { index: 1, category: "E-commerce", title: "E-commerce Pro", description: "Feature-rich online store.", longDescription: "Boost your online sales with E-commerce Pro...", image: "https://placehold.co/400x350/db2777/ffffff?text=E-commerce", tags: ["E-commerce", "Store", "Business", "React", "Shopify"] },
             { index: 2, category: "Blog", title: "Minimal Blog", description: "Content-focused layout.", longDescription: "Put your content front and center...", image: "https://placehold.co/400x350/16a34a/ffffff?text=Blog", tags: ["Blog", "Minimal", "Content", "SEO", "Writing"] },
             { index: 3, category: "Landing Page", title: "SaaS Landing Page", description: "Convert visitors effectively.", longDescription: "High-converting landing page template...", image: "https://placehold.co/400x350/ca8a04/ffffff?text=SaaS+Landing", tags: ["SaaS", "Landing Page", "Startup", "Lead Gen", "Software"] },
             { index: 4, category: "Portfolio", title: "Agency Showcase", description: "Professional look for agencies.", longDescription: "Showcase your agency's services...", image: "https://placehold.co/400x350/0ea5e9/ffffff?text=Agency", tags: ["Agency", "Business", "Portfolio", "Corporate", "Services"] },
             { index: 5, category: "Blog", title: "Travel Blog", description: "Share your adventures visually.", longDescription: "A visually rich blog template perfect for travel writers...", image: "https://placehold.co/400x350/0d9488/ffffff?text=Travel+Blog", tags: ["Blog", "Travel", "Photography", "Content", "Adventure"] },
             { index: 6, category: "E-commerce", title: "Craft Store", description: "Charming store for artisans.", longDescription: "A friendly and warm e-commerce template ideal for selling handmade goods...", image: "https://placehold.co/400x350/c026d3/ffffff?text=Craft+Store", tags: ["E-commerce", "Handmade", "Artisan", "Store", "Crafts"] }
        ];

        // --- State (Same as v5) ---
        let currentTemplateData = [...allTemplateData];
        let cards = [];
        let activeIndex = 0;
        let currentFilter = 'All';
        let searchTerm = '';
        let isAnimatingFilter = false;
        let debounceTimer;
        let stars = []; // Array for star objects
        let animationFrameId; // To control animation loop

        // --- Utility Functions (Same as v5) ---
        function debounce(func, delay) { /* Same as v5 */
            return function(...args) { clearTimeout(debounceTimer); debounceTimer = setTimeout(() => { func.apply(this, args); }, delay); };
        }

        // --- Core Logic (applyFiltersAndSearch - Same as v5) ---
        function applyFiltersAndSearch() { /* Same as v5 */
            if (isAnimatingFilter) return; isAnimatingFilter = true;
            cards.forEach(card => card.classList.add('fade-out'));
            setTimeout(() => {
                let filteredByCategory = (currentFilter === 'All') ? [...allTemplateData] : allTemplateData.filter(item => item.category === currentFilter);
                const lowerSearchTerm = searchTerm.toLowerCase().trim();
                if (lowerSearchTerm) { currentTemplateData = filteredByCategory.filter(item => (item.title.toLowerCase().includes(lowerSearchTerm) || item.description.toLowerCase().includes(lowerSearchTerm) || item.longDescription.toLowerCase().includes(lowerSearchTerm) || item.category.toLowerCase().includes(lowerSearchTerm) || item.tags.some(tag => tag.toLowerCase().includes(lowerSearchTerm)))); }
                else { currentTemplateData = filteredByCategory; }
                activeIndex = 0; populateDeck(currentTemplateData); isAnimatingFilter = false;
            }, 300);
        }

        // --- Populate Deck (Same as v5) ---
        function populateDeck(dataToDisplay) { /* Same as v5 */
            deck.innerHTML = ''; noResultsMessage.style.display = 'none';
            if (!dataToDisplay || dataToDisplay.length === 0) { noResultsMessage.style.display = 'flex'; cards = []; updateDeck(); return; }
            dataToDisplay.forEach((data, displayIndex) => {
                const card = document.createElement('div'); card.classList.add('card', 'fade-in'); card.dataset.index = data.index; card.style.animationDelay = `${displayIndex * 0.05}s`;
                const img = document.createElement('img'); img.src = data.image; img.alt = `${data.title} Preview`; img.onerror = function() { this.onerror = null; this.src = `https://placehold.co/400x350/cccccc/ffffff?text=Image+Error`; };
                const content = document.createElement('div'); content.classList.add('card-content'); const textContent = document.createElement('div');
                const title = document.createElement('h3'); title.classList.add('card-title'); title.textContent = data.title; const description = document.createElement('p'); description.classList.add('card-description'); description.textContent = data.description; textContent.appendChild(title); textContent.appendChild(description);
                const tagsContainer = document.createElement('div'); tagsContainer.classList.add('card-tags'); data.tags.slice(0, 3).forEach(tagText => { const tag = document.createElement('span'); tag.classList.add('card-tag'); tag.textContent = tagText; tagsContainer.appendChild(tag); });
                content.appendChild(textContent); content.appendChild(tagsContainer); card.appendChild(img); card.appendChild(content); deck.appendChild(card);
            });
            cards = Array.from(deck.getElementsByClassName('card')); addCardClickListeners(); addHoverEffectListeners(); updateDeck();
        }

        // --- Deck Logic (updateDeck - Same as v5) ---
        function updateDeck() { /* Same as v5 */
            if (cards.length === 0) { prevBtn.style.display = 'none'; nextBtn.style.display = 'none'; return; }
            prevBtn.style.display = 'block'; nextBtn.style.display = 'block';
            cards.forEach((card) => {
                card.classList.remove('active', 'prev', 'next', 'prev-hidden', 'next-hidden', 'hidden'); const cardDataIndex = parseInt(card.dataset.index, 10); const currentIndexInFiltered = currentTemplateData.findIndex(item => item.index === cardDataIndex); if (currentIndexInFiltered === -1) { card.classList.add('hidden'); return; } const totalCards = currentTemplateData.length; const diff = currentIndexInFiltered - activeIndex; const position = (diff + totalCards) % totalCards; card.style.transform = ''; /* Reset hover tilt */
                switch (position) { case 0: card.classList.add('active'); break; case 1: card.classList.add('next'); break; case 2: card.classList.add('next-hidden'); break; case totalCards - 1: card.classList.add('prev'); break; case totalCards - 2: card.classList.add('prev-hidden'); break; default: card.classList.add('hidden'); break; }
            });
        }

        // --- Event Listeners (Deck Navigation, Card Clicks - Same as v5) ---
        nextBtn.addEventListener('click', () => { if (cards.length === 0 || isAnimatingFilter) return; activeIndex = (activeIndex + 1) % currentTemplateData.length; updateDeck(); });
        prevBtn.addEventListener('click', () => { if (cards.length === 0 || isAnimatingFilter) return; activeIndex = (activeIndex - 1 + currentTemplateData.length) % currentTemplateData.length; updateDeck(); });
        function addCardClickListeners() { /* Same as v5 */ cards.forEach(card => { card.addEventListener('click', () => { if (isAnimatingFilter) return; const cardDataIndex = parseInt(card.dataset.index, 10); const currentIndexInFiltered = currentTemplateData.findIndex(item => item.index === cardDataIndex); if (isNaN(currentIndexInFiltered)) return; if (currentIndexInFiltered === activeIndex) { openModal(cardDataIndex); } else { activeIndex = currentIndexInFiltered; updateDeck(); } }); }); }

        // --- Modal Logic (Same as v5) ---
        function openModal(originalIndex) { /* Same as v5 */ const data = allTemplateData.find(item => item.index === originalIndex); if (!data) return; modalImage.src = data.image.replace('350', '400'); modalImage.alt = `${data.title} Large Preview`; modalTitle.textContent = data.title; modalDescription.textContent = data.longDescription || data.description; modalTags.innerHTML = ''; data.tags.forEach(tagText => { const tag = document.createElement('span'); tag.classList.add('modal-tag'); tag.textContent = tagText; modalTags.appendChild(tag); }); modalOverlay.classList.add('visible'); }
        function closeModal() { modalOverlay.classList.remove('visible'); }
        modalCloseBtn.addEventListener('click', closeModal);
        modalOverlay.addEventListener('click', (event) => { if (event.target === modalOverlay) closeModal(); });

        // --- Filtering Logic (Same as v5) ---
        function setupFilters() { /* Same as v5 */ const categories = ['All', ...new Set(allTemplateData.map(item => item.category))]; filterContainer.innerHTML = ''; categories.forEach(category => { const button = document.createElement('button'); button.classList.add('filter-button'); button.textContent = category; button.dataset.filter = category; if (category === currentFilter) { button.classList.add('active'); } button.addEventListener('click', handleFilterClick); filterContainer.appendChild(button); }); }
        function handleFilterClick(event) { /* Same as v5 */ const newFilter = event.target.dataset.filter; if (newFilter === currentFilter || isAnimatingFilter) return; currentFilter = newFilter; filterContainer.querySelectorAll('.filter-button').forEach(btn => { btn.classList.toggle('active', btn.dataset.filter === currentFilter); }); applyFiltersAndSearch(); }

        // --- Search Logic (Same as v5) ---
        const handleSearchInput = debounce(() => { searchTerm = searchInput.value; applyFiltersAndSearch(); }, 350);
        searchInput.addEventListener('input', handleSearchInput);
        searchInput.addEventListener('focus', () => { searchContainer.classList.add('search-focused'); });
        searchInput.addEventListener('blur', () => { searchContainer.classList.remove('search-focused'); });

        // --- Hover Tilt Effect Logic (Same as v5) ---
        function addHoverEffectListeners() { /* Same as v5 */ deckContainer.addEventListener('mousemove', handleTilt); deckContainer.addEventListener('mouseleave', resetTilt); }
        function handleTilt(e) { /* Same as v5 */ if (cards.length === 0 || isAnimatingFilter) return; const activeCard = cards.find(card => { const cardDataIndex = parseInt(card.dataset.index, 10); const currentIndexInFiltered = currentTemplateData.findIndex(item => item.index === cardDataIndex); return currentIndexInFiltered === activeIndex; }); if (!activeCard) return; const rect = activeCard.getBoundingClientRect(); const x = e.clientX - rect.left - rect.width / 2; const y = e.clientY - rect.top - rect.height / 2; const maxTilt = 8; const rotateY = (x / (rect.width / 2)) * maxTilt; const rotateX = (-y / (rect.height / 2)) * maxTilt; let baseTransform = ''; if (activeCard.classList.contains('active')) baseTransform = 'translateX(0) translateZ(0) rotateY(0)'; activeCard.style.transition = 'transform 0.1s ease-out'; activeCard.style.transform = `${baseTransform} rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(1.02)`; }
        function resetTilt() { /* Same as v5 */ if (cards.length === 0) return; const activeCard = cards.find(card => { const cardDataIndex = parseInt(card.dataset.index, 10); const currentIndexInFiltered = currentTemplateData.findIndex(item => item.index === cardDataIndex); return currentIndexInFiltered === activeIndex; }); if (activeCard) { activeCard.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1)'; activeCard.style.transform = ''; } }


        // --- Animated Star Background Logic ---
        function setupCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            stars = []; // Reset stars on resize
            const numStars = Math.floor((canvas.width * canvas.height) / 8000); // Adjust density based on screen area
            for (let i = 0; i < numStars; i++) {
                stars.push(new Star());
            }
        }

        class Star {
            constructor() {
                this.reset();
                this.y = Math.random() * canvas.height; // Start stars anywhere vertically
            }

            reset() {
                this.x = Math.random() * canvas.width;
                this.y = -Math.random() * 50; // Start above the screen
                // Vary size and speed for depth effect
                const sizeFactor = Math.random();
                this.size = sizeFactor * 1.5 + 0.5; // Size between 0.5 and 2
                this.speed = sizeFactor * 1.5 + 0.5; // Speed between 0.5 and 2
                this.opacity = sizeFactor * 0.5 + 0.3; // Opacity between 0.3 and 0.8
                this.trailLength = Math.floor(sizeFactor * 10) + 5; // Trail length 5-15
                this.history = [];
            }

            update() {
                this.y += this.speed;

                // Add current position to history for trail
                this.history.push({ x: this.x, y: this.y });
                if (this.history.length > this.trailLength) {
                    this.history.shift(); // Remove oldest point
                }

                // Reset if star goes off screen
                if (this.y - this.size > canvas.height) {
                    this.reset();
                }
            }

            draw() {
                // Draw Trail
                if (this.history.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(this.history[0].x, this.history[0].y);
                    for (let i = 1; i < this.history.length; i++) {
                        const segmentOpacity = (i / this.history.length) * this.opacity * 0.7; // Fade trail
                        ctx.lineTo(this.history[i].x, this.history[i].y);
                        ctx.strokeStyle = `rgba(255, 255, 255, ${segmentOpacity})`;
                        ctx.lineWidth = this.size * (i / this.history.length); // Trail thins out
                        ctx.stroke(); // Stroke each segment individually for fading width/opacity
                        ctx.beginPath(); // Start new path for next segment
                        ctx.moveTo(this.history[i].x, this.history[i].y);
                    }
                }


                // Draw Star Head
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                // Optional: Add subtle glow
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowBlur = this.size * 3;
                ctx.fill();
                // Reset shadow for other drawings
                ctx.shadowBlur = 0;
            }
        }

        function animateStars() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            // Sort stars by size (draw smaller ones first for depth) - optional optimization
            // stars.sort((a, b) => a.size - b.size);

            stars.forEach(star => {
                star.update();
                star.draw();
            });

            animationFrameId = requestAnimationFrame(animateStars); // Loop animation
        }

        // --- Initial Setup ---
        window.addEventListener('resize', () => {
            // Debounce resize handling
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                 cancelAnimationFrame(animationFrameId); // Stop previous loop
                 setupCanvas(); // Re-initialize canvas and stars
                 animateStars(); // Start new loop
            }, 250);
        });

        // Initial setup for deck and stars
        setupFilters();
        populateDeck(currentTemplateData);
        setupCanvas();
        animateStars(); // Start the star animation

    </script>

</body>
</html>
